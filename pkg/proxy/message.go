package proxy

import (
	"fmt"
	"strings"

	"github.com/romashorodok/protoc-gen-fetch-types/pkg/resources"
	"google.golang.org/protobuf/types/descriptorpb"
)

type MessageProxy struct {
	*descriptorpb.DescriptorProto

	registry *Registry
	file     *descriptorpb.FileDescriptorProto

	// Indicates the origin field when the proxy is generated by another proxy field.
	origin *descriptorpb.FieldDescriptorProto
}

func (p *MessageProxy) GetPackageName() string {
	return p.file.GetPackage()
}

func (p *MessageProxy) GetFilenameProtoID() resources.FilenameProtoID {
	return fmt.Sprintf("%s%s%s", p.file.GetName(), filenameSeparator, p.GetName())
}

// Search message in current package
func (p *MessageProxy) searcLocalMessageByTypeName(typeName string) *MessageProxy {
	typeNameParts := strings.Split(typeName, ".")
	typeNameSuffix := typeNameParts[len(typeNameParts)-1]
	localMessage := fmt.Sprintf("%s%s%s", p.file.GetName(), filenameSeparator, typeNameSuffix)
	{
		message, exist := p.registry.Message[localMessage]
		if exist {
			return message
		}
	}
	return nil
}

func (p *MessageProxy) searchMessageByTypeName(typeName string) *MessageProxy {
	if localMessage := p.searcLocalMessageByTypeName(typeName); localMessage != nil {
		return localMessage
	}

	typeNameParts := strings.Split(typeName, ".")
	typeNameSuffix := typeNameParts[len(typeNameParts)-1]
	for _, dependencyFile := range p.file.GetDependency() {
		filenameProtoID := fmt.Sprintf("%s:%s", dependencyFile, typeNameSuffix)
		message, exist := p.registry.Message[filenameProtoID]
		if !exist {
			continue
		}

		targetTypeName := message.GetProtoID()
		if targetTypeName == typeName {
			return message
		}
	}

	return nil
}

func (p *MessageProxy) GetLocalFieldMessages() []*MessageProxy {
	var result []*MessageProxy
	for _, field := range p.Field {
		if field.GetType() != descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
			continue
		}
		message := p.searcLocalMessageByTypeName(field.GetTypeName())
		if message != nil {
			message.origin = field
			result = append(result, message)
		}
	}
	return result
}

func (p *MessageProxy) GetFieldsMessages() []*MessageProxy {
	var result []*MessageProxy
	for _, field := range p.Field {
		if field.GetType() != descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
			continue
		}
		message := p.searchMessageByTypeName(field.GetTypeName())
		if message != nil {
			message.origin = field
		}
		result = append(result, message)
	}
	return result
}

func (p *MessageProxy) GetPrimitiveFields() []*descriptorpb.FieldDescriptorProto {
	var result []*descriptorpb.FieldDescriptorProto
	for _, field := range p.Field {
		if field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
			continue
		}
		result = append(result, field)
	}
	return result
}

func (p *MessageProxy) GetOriginField() (*descriptorpb.FieldDescriptorProto, error) {
	if p.origin == nil {
		return nil, NotFoundOriginError
	}
	return p.origin, nil
}

func (p *MessageProxy) GetProtoID() string {
	return fmt.Sprintf(".%s.%s", p.file.GetPackage(), p.GetName())
}

func (p *MessageProxy) GetTsNamespacePath() string {
	return GetNamespace(p.file)
}

func (p *MessageProxy) GetFile() *descriptorpb.FileDescriptorProto {
	return p.file
}

var _ ProtoProxy = (*MessageProxy)(nil)

type NewMessageProxyParams struct {
	DescriptorProto *descriptorpb.DescriptorProto
	Registry        *Registry
	File            *descriptorpb.FileDescriptorProto
}

func NewMessageProxy(params *NewMessageProxyParams) *MessageProxy {
	return &MessageProxy{
		DescriptorProto: params.DescriptorProto,
		registry:        params.Registry,
		file:            params.File,
	}
}
